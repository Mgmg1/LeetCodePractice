package Leet1;

/*
    搜索旋转排序数组II
    相比搜索旋转排序数组I，这里允许元素重复！！

    思路1：去除重复的元素，使得问题变为搜索旋转排序数组I O(n) 时间复杂度
    思路2：在得到arr[middle]后，O(n)循环挖去重复的元素。这样时间复杂度提升到了O(n)，并且当数组的前后两端相等时，无法判断。
    思路3？

 */
public class Leet81 {

    public static void main(String[] args) {

    }

    /*
        当数组的前后两端相等时，搜索旋转排序数组I的方法失效！！
        此时无法判断数组分布情况是  ---------》---》 还是   ---》--------》

        设想一种极端情况下，目标元素只有一个，其它的所有元素都相等，那么如何找到target？
        如 88898888888  和   88888889888  ，事实上，两个都是旋转排序数组
        如何以比 O(n) 更低的时间复杂度来解决这个问题？？？
     */
//    public static int searchSortSpinRotateArr(int[] arr,int num ) {
//
//
//
//    }

}
